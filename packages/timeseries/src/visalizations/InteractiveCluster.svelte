<script lang="ts">
    import type { ClusterNode } from "../utils/main";
    import { InteractiveClusters } from "../interactiveClusters/interactiveClusters";
    import type { ClusterLeaf } from "../interactiveClusters/clusterNode";
    import { HedgehogClusterVisualisation, SphereClusterVisualisation, PCAClusterVisualisation, SDGClusterVisualisation, PathlineClusterVisualization } from "../interactiveClusters/visualisations/index";
    import { getContext, onMount } from "svelte";
    import type { Writable } from "svelte/store";
    import type { Viewport3D } from "lib-graphics";
    import type { vec3 } from "gl-matrix";
    import * as Graphics from "lib-graphics";
    import { vec2 } from "gl-matrix";

    let viewport: Writable<Viewport3D | null> = getContext("viewport");
    let device: Writable<GPUDevice> = getContext("device");

    export let dataClustersGivenK: ClusterNode[][] | null = null;
    export let points: vec3[] = [];
    export let clusterVisualization: string;
    export let showConnections: Boolean = false;

    let clusterObjects: InteractiveClusters = null;
    let canvas: HTMLElement | null = null;

    const representations = {
      "Sphere": SphereClusterVisualisation,
      "Hedgehog": HedgehogClusterVisualisation,
      "Cones": PCAClusterVisualisation,
      "SignedDistanceGrid": SDGClusterVisualisation,
      "Pathline": PathlineClusterVisualization
    };

    function onElementRightButtonClick(event) {
		  let rect = canvas.getBoundingClientRect(); // abs. size of element    
      let ray = Graphics.screenSpaceToRay(vec2.fromValues((event.clientX - rect.left) / rect.width, (event.clientY - rect.top) / rect.height), $viewport.camera);

      let hitCluster: ClusterLeaf = clusterObjects.rayIntersection(ray);
      if (hitCluster != null) hitCluster.split(dataClustersGivenK, points);
    }

    // TODO: fix number of octopi tentacles when any cluster is split
    function onElementLeftButtonClick(event) {
		  let rect = canvas.getBoundingClientRect(); 
      let ray = Graphics.screenSpaceToRay(vec2.fromValues((event.clientX - rect.left) / rect.width, (event.clientY - rect.top) / rect.height), $viewport.camera);

      let hitCluster: ClusterLeaf = clusterObjects.rayIntersection(ray);
      if (hitCluster != null) {
        let chosenRepresentation = representations[clusterVisualization];
        hitCluster.setVisualisation(chosenRepresentation, points);
        hitCluster.updatePoints(points);
      }
	  }
  
    $: if ($viewport) {
      if (clusterObjects == null) {
        clusterObjects = new InteractiveClusters(dataClustersGivenK, points, $viewport, $device);
        canvas = document.getElementById("canvas");
        canvas?.addEventListener("mousedown", event => {
          if (event.button == 0) { // left click for mouse
              onElementLeftButtonClick(event);
          }});
        canvas?.addEventListener("contextmenu", (event) => { // right click for mouse
          event.preventDefault();
          onElementRightButtonClick(event);
        });
      }
    }

    $: if (clusterObjects) {
      clusterObjects.setShowConnectors(showConnections);
    }

    $: if ($viewport && points) {
      clusterObjects.updatePoints(points);
    }

    /*
      This function is here to prevent Svelte seeing *points* as a reactive variable
      in the following reactive statement. This causes the reactive statement to only
      fire in case clustersGivenK is updated
    */
    function updateClusters(dataClustersByK: ClusterNode[][]) {
      if (clusterObjects && points) {
        clusterObjects.updateClusters(points, dataClustersByK);
        clusterObjects.updatePoints(points);
      }
    }

    $: if ($viewport && dataClustersGivenK) {
      updateClusters(dataClustersGivenK);
    } 

    onMount(() => {
      return () => {
        if (clusterObjects)
          clusterObjects.delete();
        canvas = document.getElementById("canvas");
        //canvas?.removeEventListener("mousedown", onElementButtonClick); 
      };
    });
  </script>
  